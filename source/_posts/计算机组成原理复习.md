---
title: 计算机组成原理复习
date: 2019-07-05 10:17:47
tags: 
- 计算机组成原理
categories: 
- 计算机科学
---
<style>
img {
  width:50%;
}
</style>
# 第三章重点：总线传输率、波特率比特率、总线优先仲裁等； 
计算机五大部件互连方式：分散连接、总线连接  
总线：连接多个部件的信息传输线，是各部件共享的传输介质  
总线分类：
+ 片内总线：芯片内部
+ 系统总线：各大部件的信息传输线
+ 通信总线：计算机系统之间或与其他系统之间的通信
 <!--more  -->

## 总线控制
主设备对总线有控制权，从设备只能响应从主设备发来的总线命令，对总线没有控制权。  
### 总线判优控制
+ 集中式（控制逻辑集中在一处）
  + 链式查询
    + 离总线控制部件最近的设备具有最高的优先级
    + 结构简单，但对电路故障很敏感，且优先级低的设备可能很难获得请求<br>
  ![链式查询方式](https://raw.githubusercontent.com/VinceMar/hexo_pic/master/img/F0Q04K%60Z3IC(TT42P6DT_8T.png)
  + 计数器定时查询
    + 当某个请求占用总线的设备地址与计数值一致时，便获得总线使用权
    + 相比于链式查询，该方式优先次序可以改变，且电路故障敏感度低，但增加了控制线数量，控制较为复杂<br>
  ![计数器定时查询](https://raw.githubusercontent.com/VinceMar/hexo_pic/master/img/%25X5R%5DKMRT3%5D%40MI%248J_IW(Z1.png)
  + 独立请求方式
    + 总线控制部件中的排队器可根据优先次序确定响应哪一台设备的请求
    + 优先次序灵活，但控制线多，控制更复杂<br>
  ![独立请求方式](https://raw.githubusercontent.com/VinceMar/hexo_pic/master/img/PMZZ90A%7EZ_G4%243MMVSQ_GUO.png)
+ 分布式（控制逻辑分散在与总线连接的各个部件）
### 总线通信控制
解决通信双方协调配合问题  
#### 总线传输周期：
1. 申请分配阶段：主模块申请，总线仲裁决定
2. 寻址阶段：主模块向从模块给出地址和命令
3. 传数阶段：主从模块交换数据
4. 结束阶段：主模块撤销有关信息
#### 总线通信四种方式
1. 同步通信：由统一时标控制数据传送
2. 异步通信：采用应答方式
   ![应答方式](https://raw.githubusercontent.com/VinceMar/hexo_pic/master/img/20190706104200.png)
3. 半同步通信：同步、异步结合，增设“等待”响应信号线
4. 分离式通信：充分挖掘系统总线每个瞬间的潜力

$$波特率 ＝ 比特率/每符号含的比特数$$
# 第四章重点：多体存储器、DRAM刷新、内存扩展、CACHE映像  
![](https://raw.githubusercontent.com/VinceMar/hexo_pic/master/img/20190706205002.png)
![](https://raw.githubusercontent.com/VinceMar/hexo_pic/master/img/20190707103059.png)

## 主存中存储单元地址的分配:  
地址线24根,按字节寻址范围为$2^{24} =16M$

若字长32位,则一个字有4个字节,所以要留2根地址线指出该字中的哪个字节[00,01,10,11],即寻址范围为 $2^{24}−2=4M$;

若字长16位,则一个字有2个字节,所以要留1根地址线指出该字中的哪个字节[0,1],即寻址范围为 $2^{24} −1=8M$;  
## 主存的技术指标：
存储容量：主存能存放二进制代码的总位数  
存储速度：由存取时间和存取周期来表示  
  + 存储器带宽：单位时间内存储器存取的信息量    

半导体存储芯片：地址线和数据线的位数共同反映存储芯片的容量，如地址线10根，数据线4根，则芯片容量为$2^{10}*4=4K$ 
![](https://raw.githubusercontent.com/VinceMar/hexo_pic/master/img/20190708100951.png)  
![](https://raw.githubusercontent.com/VinceMar/hexo_pic/master/img/20190708101206.png)  
Cache的容量与块长是影响Cache效率的重要因素，通常用“命中率”来衡量Cache的效率。
# 第五章重点：传输控制方式  
简要描述外设进行DMA操作的过程及DMA方式的主要优点。
(1)外设发出DMA请求；
(2)CPU响应请求，DMA控制器从CPU接管总线的控制；
(3)由DMA控制器执行数据传送操作；
(4)向CPU报告DMA操作结束。
主要优点是数据数据速度快

# 第六章重点：浮点数加减法  
1. 浮点加减法的运算步骤

　　前面已讲到,浮点数经常被写成如下的形式：
　　　　　　　　X　=　Mx * 2Ex

　　其中Mx为该浮点数的尾数,一般为绝对值小于1的规格化的二进制小数,机器中多用原码（或补码）形式表示。Ex为该浮点数的阶码,一般为二进制整数,机器中多用移码（或补码）表示，给出的是一个指数的幂，而该指数的底常用2、8或16,我们这里先以2为底作例子进行讨论。
　　浮点加减法的运算步骤
　　假定有两个浮点数
　　　　　X　=　Mx * 2Ex ， Y　=　My * 2Ey

　　1. 实现X±Y运算,要用如下五步完成:
　　(1) 对阶操作,即比较两个浮点数的阶码值的大小.求△E=Ex-Ey。当其不等于零时,首先应使两个数取相同的阶码值。其实现方法是,将原来阶码小的数的尾数右移|△E|位,其阶码值加上|△E|,即每右移一次尾数要使阶码加1,则该浮点数的值不变(但精度变差了)。尾数右移时,对原码形式的尾数,符号位不参加移位,尾数高位补0;对补码形式的尾数,符号位要参加右移并使自己保持不变。为减少误差,可用
　　另外的线路,保留右移过程中丢掉的一到几位的高位值,供以后舍入操作使用。

　　(2) 实现尾数的加(减)运算,对两个完成对阶后的浮点数执行求和(差)操作。

　　(3) 规格化处理,若得到的结果不满足规格化规则,就必须把它变成规格化的数,对双符号位的补码尾数来说,就必须是001××…×或
　
　　110××…×的形式。这里的规格化处理规则是:
　　.当结果尾数的两个符号位的值不同时,表明尾数运算结果溢出。此时应使结果尾数右移一位,并使阶码的值加1,这被称为向右规格化,简称右规。

　　.当尾数的运算结果不溢出,但最高数值位与符号位同值,表明不满足规格化规则,此时应重复地使尾数左移、阶减减1,直到出现在最高数值位上的值与符号位的值不同为止,这是向左规格化的操作,简称左规。

　　(4) 舍入操作。在执行对阶或右规操作时,会使尾数低位上的一位或多位的数值被移掉,使数值的精度受到影响,可以把移掉的几个高位的值保存起来供舍入使用。舍入的总的原则是要有舍有入,而且尽量使舍和入的机会均等,以防止误差积累。常用的办法有"0"舍"1"入法,即移掉的最高位为1时 则在尾数末位加1;为0时则舍去移掉的数值。该方案的最大误差为2-（n+1）。这样做可能又使尾数溢出,此时就要再做一次右规。另一种方法 "置1"法,即右移时,丢掉移出的原低位上的值,并把结果的最低位置成1。该方案同样有使结果尾数变大或变小两种可能。即舍入前尾数最低位已为0,使其变1,对正数而言,其值变大,等于最低位入了个1。若尾数最低位已为1,则再对其置1无实际效用,等于舍掉了丢失的尾数低位值。

　　(5) 判结果的正确性,即检查阶码是否溢出。浮点数的溢出是以其阶码溢出表现出来的。在加减运算真正结束前,要检查是否产生了溢出,若阶码正常，加(减)运算正常结束；若阶码下溢,要置运算结果为浮点形式的机器零,若上溢,则置溢出标志。

# 第七章重点：指令码扩展技术  

需要建立的一种直观的认知是：既然是扩展操作码，就意味着操作码的位数越变越多！ 
之所以这么强调，是因为常常混淆了操作码的扩展方向。

再看扩展的原理： 
假设指令字长是16位，平均劈开成4份，高位4位用作操作码，低12位分别用作三个地址码。

那么操作码的个数就是四个二进制所能表达的离散数目：24=1624=16
OK，如果地址码只能做地址码，这是最终的结局了。 
但是，如果地址码可以化身为操作码，这并不难对吧，毕竟都是二进制的数位而已。 
非常粗略的认为，现在第一个地址4位也用作操作码，那么总的看来就是高8位用作操作码，低8位用作两个地址码了。

按理说28=25628=256，即，共计有256种操作码。 
虽然，用8位和用4位各自表达操作码，互不干扰的。但是，实际上呢，单操作码只有15条，且二地址的操作码只有16条，如果还要继续扩展，二地址的也只有15条了！ 
为什么差别这么大？ 
答案是两个原则不可以破：

不允许短码是长码的前缀
各指令的操作码一定不能重复
为了满足第一条，我们看8位操作码的时候，前面四位全是四位操作码已经出现过的! 
所以，设计思路只能变成：前面四位只用15种离散状态，保留一个给二地址扩展用。因此，8位操作码，实际上限定了高4位的值，只是低四位可以离散，共16种状态，要想再继续扩展，自己最多只敢用15种，还得保留一个种子呢！

这便是整个的扩展操作码的原理。当然可以有其他变种，这里不做展开。

看一个例子：

一个计算机系统采用32位单字长指令，地址码是12位，如果定义了250条二地址指令，那么还有(24K )条单地址指令。

怎么理解，这里的地址码限定为12位，说的是一个地址码就12位，如果有2个地址，那就是24位了！我会下意识的以为，哦，只分配12位作地址码，这是不对的。

由原理分析我们知道得问自己一下，这个是不是从三地址开始扩展来的?计算一下，12*3 = 36,超过了总的位数，因此，二地址是起点。之所以这么想，是因为我们知道二地址不一定是扩展的起点。 
二地址共用掉24位作操作数地址，高位有8位作操作码。共有28=25628=256种操作码状态，现在只用了250种，因此，还有6个可以供下一个扩展用，一地址码就意味着有中间12位可以做操作码，于是根据乘法原理：6∗212=24K6∗212=24K. 这里不考虑继续扩展成0地址码，因为问的是可以有，考虑的是最多可以有，是上限值。

PS: 210=1K,220=1M,230=1G210=1K,220=1M,230=1G,乘法原理就是分步用乘法，比如高位有6个状态，再第二步有212212种 ，乘起来就是结果。

以上。